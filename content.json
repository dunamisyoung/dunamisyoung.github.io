{"pages":[{"title":"about","text":"👨‍💻 안녕하세요 Asher입니다! 👨‍💻 2019년 7월 쇼핑몰 창업을위해 웹디자인공부로 시작했던 공부가 현재는 FE 개발자가 되기위해 부단히 노력하고있습니다 :)미흡하거나 부족한 점이 많아 조언해주고 싶으신 부분이 있다면 댓글로 남겨주세요!방문해주셔서 감사합니다😁 In his heart a man plans his course, but the LORD determines his steps. (Proverbs 16:9)","link":"/about/dunamisyoung.html"}],"posts":[{"title":"RSS란?","text":"RSS = Real Simple Syndication - 진짜 심플한 배급 or Rich Site Summary - 풍부한 사이트 요약 예를 들어봅시다!관심있는 유튜브를 매일 방문해서 재미있는 새로운 콘텐츠가 있는지는 확인하기 번거롭습니다. 특히 정기적으로 게시물이 올라오지 않는경우에는 더욱 그렇습니다. 그 사이트를 직접 방문하지 않고 새로운 콘텐츠가 올라왔을경우만 본인의 컴퓨터로 전달이 된다면 편리할것입니다. - 일종의 알림설정처럼 RSS는 새로운 기사들의 제목이나 글의 전체를 뽑아 하나의 파일로 만들어 놓은것입니다. (XML 형식) 이제 각 사이트에서 제공하는 RSS 파일 주소만 수집하여 확인하면 자신의 취향에 맞는 새로운 정보를 쉽게 찾아 읽을수있습니다. 모든 사이트에서 RSS가 사용되는것은 아니고 주로 새로운 내용이 없는 정적인 사이트에 제공하지 않고 블로그나 뉴스형 사이트에서 주로 제공됩니다. RSS 피드 주소를 얻어 RSS리더기에 주소를 넣어 구독을 하게되면 RSS리더기가 자동으로 알려주고 보여주게됩니다. 쉽게 이해하자면 RSS피드 주소는 게시물을 올리는 유튜버의 고유주소, RSS리더기는 구독+알림설정 정도가 되겠습니다. RSS의 장점 예를 들어 블로그 같은경우 email을 입력해 구독을 권장하는 경우가 있는데 이러한경우 개인정보 유출의 위험이 있다. 하지만 RSS 피드를 사용해서 구독한다면 신뢰하지 못하는 사이트의 경우에도 어떠한 정보를 알려줄 필요가 없기에 안전하다. 참조 [꿀팁] 초보자를 위한 RSS 란? RSS의 뜻과 의미는? 레알! 쉽게 이해할 수 있음 RSS - 위키백과","link":"/2021/03/31/RSS%EB%9E%80/"},{"title":"VanilaJS-Array","text":"자료구조상의 배열은 동일한 크기의 메모리공간이 빈틈없이 연속되는 자료구조를 뜻하며, 하나의 데이터타입을 가지고 있는것을 뜻하며 이는 밀접배열이라한다. 이러한 배열은 정렬되어있는 상태라면 접근하여 값을 찾는경우 매우빠르게 동작하겠지만, 그렇지 않은 경우에는 정렬시간과 값을 찾는시간이 더해져 효율적이지 못하게된다. 자바스크립트의 배열은 메모리공간이 동일한 크기를 가지지 않아도 되며, 연속되지 않을수있다. 자바스크립트에서 배열의 구조가 연속적으로 이어져 있지 않은 배열은 희소배열이라한다. 자바스크립트의 배열은 사실 객체이다. 자료구조상의 배열을 흉내낸 해시테이블 구조를 가진 객체이며, 배열 안의 요소는 element라고 불리운다. 배열은 자신의 위치를 나타내는 0 이상의 정수인 index를 가진다. 배열은 요소의 개수를 나타내는 length 프로퍼티를 가진다. 배열의 인덱스는 사실 프로퍼티키이며, 문자열이다. “일반 객체와 배열을 구분하는 가장 명확한 차이는 index(값의 순서)와 length 프로퍼티가 있다는 점이다.” length 프로퍼티 그리고 희소배열length 프로퍼티는 요소의 개수 즉, 배열의 길이를 나타낸다. 빈 배열일경우에는 0이며 아닐경우 가장 큰 인덱스에 1을 더한것과 같다. 12console.log([].length); // 0console.log([1, 2, 3, 4].length); // 4 희소배열은 length프로퍼티가 배열이 가진 요소의 개수보다 크고, 일부가 비어 있는 배열을 희소 배열이라고 할수있다. 123const arr = [1, 2, 3];arr.length = 100;console.log(arr); // (100) [1, 2, 3, empty × 97] 배열의 생성방식 배열리터럴 가장 기본적인 배열 생성 방식이다. 1const arr = []; // 배열리터럴 Array 생성자함수 전달된 인수가 2개 이상이거나 숫자가 아닌경우 인수를 요소로 갖는 배열이 생성된다. 이때 숫자를 넣게되면 희소배열이 만들어진다. new 연산자와 함께 호출하지 않아도 Array 생성자 함수내의 new.target에 의해 생성자함수로 동작한다. 12345const arr1 = new Array('얍');console.log(arr1); // ['얍']const arr2 = new Array(10);console.log(arr2); // (10) [empty × 10] Array.of( ) 전달된 인수가 숫자이고 1개여도 배열이 만들어진다. 12const arr = Array.of(1);console.log(arr); // [1] Array.from( ) 유사배열객체와 이터러블을 인수로 전달받아 배열로 변환해 반환한다. 123const foo = 'hello';const result = Array.from(foo);console.log(result); // (5) [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] 배열의 요소참조배열의 요소참조는 [] 대괄호 표기법을 이용해 이루어지며, 대괄호 안에는 인덱스가 와야하며, 정수로 평가되는 표현식도 인덱스 대신 사용이 가능하다. 배열의 인덱스는 프로퍼티 키이며 존재하지 않는 프로퍼티로 객체의 프로퍼티에 접근했을경우 undefied를 반환하는것처럼 배열에서도 동일하게 작동된다. 12const arr = [1, 2, 3];console.log(arr[3]); //undefined 배열 메서드배열메서드는 원본배열을 변경하는 메서드, 원본배열을 변경하지 않는 메서드 두가지로 나뉜다. 사용빈도가 비교적 높고 대표적인 배열메서드를 알아보자. Array.isArray( ) 인수로 전달된 값이 배열인지 아닌지를 확인하는 메서드이다. 반환되는 데이터타입은 boolean이다. 12345const arr1 = [1, 2, 3];const arr2 = {};console.log(Array.isArray(arr1)); // trueconsole.log(Array.isArray(arr2)); // false Array.prototype.indexOf( ) 인수로 전달된 요소를 검색해 인덱스를 반환한다. 만약 중복되는 요소가 있다면 첫번째로 검색된요소의 인덱스를 반환한다. 원본배열에 인수로 전달된 요소가 존재하지 않으면 -1을 반환한다. 두번째 인수는 검색을 시작할 인덱스이며 생략시 처음부터 검색한다. 12const arr = [1, 2, 3];console.log(arr.indexOf(2)); // 1 Array.protorype.push( ) 인수로 전달받은 값을 원본배열의 마지막요소로 추가한다. 반환되는 값은 원본배열의 length 프로퍼티이다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.push(4);console.log(arr); // [1, 2, 3, 4]console.log(result); // 4 원본배열을 훼손하는 행위는 권장하지 않는다. 그렇기에 ES6에서 추가된 스프레드 문법을 활용하는것이 바람직하다. ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [...arr, 4];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] Array.prototype.pop( ) 원본 배열의 마지막요소를 제거한다 제거된 요소를 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.pop();console.log(arr); // (2) [1, 2]console.log(result); // 3 Array.prototype.unshift( ) 원본배열의 선두요소에 인수로 전달받은 값을 추가한다. 반환되는 값은 원본배열의 length 프로퍼티이다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.unshift(4);console.log(arr); // (4) [4, 1, 2, 3]console.log(result); // 4 원본배열을 훼손하는 행위는 권장하지 않는다. 그렇기에 ES6에서 추가된 스프레드 문법을 활용하는것이 바람직하다. ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [4, ...arr];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [4, 1, 2, 3] Array.prototype.shift( ) 원본배열에서 첫번째 요소를 제거한다. 제거된 요소를 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.shift();console.log(arr); // (2) [2, 3]console.log(result); // 1 Array.prototype.concat( ) 원본배열의 마지막에 인수로 전달받은 값을 추가한다. ( 전달된 값이 배열이면 해체하여 새로운 배열의 요소로 추가한다. ) 변경된 새로운 배열을 반환한다. 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.concat(4);console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [...arr, 4];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] Array.prototype.splice( StartIndex, deleteCount, [item]) 원본배열의 중간에 요소를 추가 혹은 제거한다. StartIndex - 원본배열의 요소를 제거하기 시작할 인덱스 ( StartIndex만 지정하면 모든 요소제거 ) deleteCount - 원본배열의 요소를 제거할 개수 ( 0 이면 어느것도 제거되지 않는다. ) item - 원본배열의 요소를 제거한 위치에 삽일할 요소들의 목록 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.splice(1, 2, 3, 4);console.log(arr); // (3) [1, 3, 4]console.log(result); // (2) [2, 3] Array.prototype.slice( StartIndex, EndIndex ) 인수로 전달된 범위의 요소를 복사한다. 원본배열을 복사한 배열을 반환한다. ( 인수를 모두 생략하면 원본배열의 복사본을 생성해 반환한다. ) StartIndex - 원본배열의 복사를 시작할 인덱스 ( 음수일경우는 맨 마지막 요소에서 -n 이후의 값을 반환 ) EndIndex - 원본배열의 복사를 종료할 인덱스 ( 해당요소는 미포함 , 기본값은 length 프로퍼티 값 ) 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.slice(1, 2);console.log(arr); // (3) [1, 2, 3]console.log(result); // [2] Array.prototype.join( ) 원본배열의 모든요소를 문자열로 변환한다. 인수로 전달받은 값( 구분자 )으로 연결한 문자열을 반환한다. 기본 구분자는 콤마이다. , 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.join('');console.log(arr); // (3) [1, 2, 3]console.log(result); // 123 Array.prototype.reverse( ) 원본배열의 순서를 반대로 뒤집는다. 변경된 원본배열을 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.reverse();console.log(arr); // (3) [3, 2, 1]console.log(result); // (3) [3, 2, 1] Array.prototype.fill( _ , StartIndex, StopIndex ) ES6 인수로 전달 받은 값을 배열의 요소로 처음부터 끝까지 채운다. _ - 배열을 채울 요소 StartIndex - 요소를 채우기 시작할 인덱스 StopIndex - 요소를 채우는것을 멈출인덱스 ( 해당 요소는 미포함 ) 원본배열을 변환시킨다. 12345const arr = new Array(10);const result = arr.fill(1, 2, 10);console.log(arr); // (10) [empty × 2, 1, 1, 1, 1, 1, 1, 1, 1]console.log(result); // (10) [empty × 2, 1, 1, 1, 1, 1, 1, 1, 1] Array.prototype.includes( SearchElement, StartIndex ) ES7 원본 배열에 특정요소가 포함되어있는지 확인한다. true 혹은 false를 반환한다. SearchElement - 검색할 대상지정 StartIndex - 검색을 시작할 인덱스 12345const arr = [1, 2, 3];const result = arr.includes(2, 1);console.log(arr); // (3) [1, 2, 3]console.log(result); // true Array.prototype.flat( ) ES10 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다. 기본값은 1단계 평탄화이다. Infinity를 인수로 전달하면 중첩배열을 모두 평탄화한다. 1234console.log([1, [2, 3, 4, 5]].flat()); // (5) [1, 2, 3, 4, 5]console.log([1, [2, [3, 4, 5]]].flat(1)); // (5) [1, 2, 3, 4, 5]console.log([1, [2, [3, [4, 5]]]].flat(2)); // (4) [1, 2, 3, Array(2)]console.log([1, [2, [3, [4, [5]]]]].flat(Infinity)); // (5) [1, 2, 3, 4, 5]","link":"/2021/04/02/VanilaJS-Array/"},{"title":"VanilaJS-HOF","text":"배열고차함수 (Array Higher Order Function in JS) 고차함수(Higher-Order-Function)는 함수를 인수로 전달받거나 반환하는 함수를말한다. 자바스크립트에서 활용도가 매우높은 배열에사용되는 고차함수에 대해 알아보자. Array.prototype.sort( ) 원본배열의 요소를 정렬한다. ( 기본적으로 오름차순으로 요소를 정렬한다. ) 정렬된 배열을 반환한다. 원본배열이 변환된다. 12345const arr = [1, 3, 5, 20, 11];const result = arr.sort();console.log(arr);) // [1, 11, 20, 3, 5]console.log(result); // [1, 11, 20, 3, 5] 필자는 “sort 메서드를 따로 분류해서 페이지를 만들까?” 까지 고민할정도로 중요하고 또 어렵게 느껴졌다. 좀더 자세히 sort 메서드에 대해 알아보자. sort 메서드는 배열안의 요소에 따라 다르게 동작한다. 문자열로 이루어진 배열의 경우 숫자로 이루어진 배열의 경우 sort 메서드는 숫자로 이루어진 배열의 요소들을 일시적으로 문자열로 변환시켜 유니코드의 순서를 기준으로 정렬한다. 먼저 유니코드(Unicode)에 관해서 간단하게 설명한다면, 컴퓨터에서 사용되는 모든기호나 문자들에 관해서 컴퓨터가 이해할수있게 만들어 놓은 표기방식이라고 할수있겠다. sort메서드는 유니코드를 기준으로 배열안의 요소들을 정렬하게 되는데 기존에 문자열 같은경우는 우리가 알고있는 알파벳순서에 따라 정상적으로 잘 동작한다. 12345const fruits = ['Apple', 'Orange', 'Banana', 'Peach', 'Grape'];const result = fruits.sort();console.log(fruits); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Grape&quot;, &quot;Orange&quot;, &quot;Peach&quot;]console.log(result); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Grape&quot;, &quot;Orange&quot;, &quot;Peach&quot;] 하지만, 숫자 같은 경우 조금 다르다. 12345const arr = [1, 3, 5, 20, 11];const result = arr.sort();console.log(arr);) // [1, 11, 20, 3, 5]console.log(result); // [1, 11, 20, 3, 5] 위 예시처럼 숫자같은경우는 11과 20이 3과 5보다 먼저 정렬된다. 이는 유니코드 표기법에 의해 정렬되었기 때문이다. 즉, 숫자에서 일시적으로 문자로 변환된 문자열들을 유니코드를 기준으로 비교하면 문자열 ‘11’이 ‘20’, ‘3’, ‘5’ 보다 더 앞서기 때문이다. 비교함수 전달하기따라서 숫자요소를 정렬할때는 특별히 비교함수를 sort 메서드 안으로 전달해야한다. 0을 기준으로 오름차순과 내림 차순이 결정된다. 반환되는 값이 0 이상이면 오름차순 ( 0 &lt; returnValue ) 반환되는 값이 0 이하면 내림차순 ( 0 &gt; returnValue ) 오름차순정렬 12345678const arr = [3, 10, 21, 14, 5];const compare = (next, prev) =&gt; { return next - prev;};const result = arr.sort(compare);console.log(arr); // (5) [3, 5, 10, 14, 21]console.log(result); // (5) [3, 5, 10, 14, 21] 내림차순정렬 12345678const arr = [3, 10, 21, 14, 5];const compare = (next, prev) =&gt; { return prev - next;};const result = arr.sort(compare);console.log(arr); // (5) [21, 14, 10, 5, 3]console.log(result); // (5) [21, 14, 10, 5, 3] 위 코드의 compare 매개 변수의 이름을 잘보면 next, prev 라고 명시했다. 이는 sort 메서드 내부동작의해서 원본배열의 secondIndex가 next로 들어가고 firstIndex가 prev로 들어가기에 이렇게 작성했다. 필자는 이것을 알아내느라 하루를 소모했다..😂 sort 메서드 관련 좀더 자세한 사항은 아래의 이곳, 저곳, 요곳을 참조하면된다! 유니코드 관련 참조사이트https://ko.wikipedia.org/wiki/유니코드 https://d2.naver.com/helloworld/19187 https://graphemica.com/ https://unicode-table.com/kr/#basic-latin","link":"/2021/04/02/VanilaJS-HOF/"}],"tags":[{"name":"Technical Terms","slug":"Technical-Terms","link":"/tags/Technical-Terms/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"sort","slug":"sort","link":"/tags/sort/"}],"categories":[{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"Technical Terms","slug":"CS/Technical-Terms","link":"/categories/CS/Technical-Terms/"},{"name":"Array","slug":"JS/Array","link":"/categories/JS/Array/"}]}