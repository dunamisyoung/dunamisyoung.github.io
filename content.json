{"pages":[{"title":"about","text":"👨‍💻 안녕하세요 Asher입니다! 👨‍💻2019년 7월 쇼핑몰 창업을위해 웹디자인공부로 시작했던 공부가 현재는 FE 개발자가 되기위해 부단히 노력하고있습니다 :)미흡하거나 부족한 점이 많아 조언해주고 싶으신 부분이 있다면 댓글로 남겨주세요!방문해주셔서감사합니다😁 In his heart a man plans his course, but the LORD determines his steps. (Proverbs 16:9)","link":"/about/index.html"}],"posts":[{"title":"CrossPlatform","text":"크로스 플랫폼?크로스 플랫폼 (영어: cross-platform) 또는 멀티 플랫폼 (영어: multi-platform)은 컴퓨터 프로그램, 운영 체제, 컴퓨터 언어, 프로그래밍 언어, 컴퓨터 소프트웨어 등이 여러 종류의 컴퓨터 플랫폼에서 동작할 수 있다는 것을 뜻하는 용어이다. - 위키백과 예를 들어보자. 대중적으로 많이 사용하고 있는 IDE(통합개발환경) 인 비주얼 스튜디오 코드는 마이크로소프트사인 윈도우는 물론, 맥, 리눅스 환경에서도 잘동작한다. 각자 키보드나 디렉터리 구조 차이 같은 것들이 있긴하지만 어떤 운영체제에서도 비슷하게 사용이가능하다. 이는 비주얼 스튜디오 코드가 크로스 플랫폼 프레임 워크인 일렉트론을 기반으로 하고 있기 때문이다. 이처럼 여러종류의 컴퓨터 플랫폼(MAC OS, Linux, Window)에서 동작 할 수 있는 것을 의미한다. 웹 그리고 모바일 시장의 크로스 플랫폼과 네이티브현재 IT 시장에서 서비스를 출시할경우 앱이 없어서는 안되는 경우가 대부분이다. 웹 뿐만아니라 모바일 소프트 웨어 업계에서도 최근에 크로스 플랫폼 바람이 불고있다. 이는 개발자들이 Android 와 iOS 에 대응하는 각각의 어플리케이션을 중복적으로 개발하지 않고 양쪽 OS에 대응하는 앱을 만들수 있기때문이다. 또한 앱개발에 필요한 개발자가 줄어들기에 소스 코드 관리가 편해질수있다. 크로스 플랫폼의 종류 ReactNative - facebook 자마린 - microsorft Flutter - Google 이러한 크로스플랫폼들을 사용하기 위해서는 결국 Native와 관련된 지식과 기술들이 필요하다고 한다. 하지만 구글에서 Flutter 라는 크로스 플랫폼을 만들었는데 이는 기존의 Native UI를 무시하고 사용할수 있다고한다. 하지만 Dart라는 언어를 배워야한다는 것과, 구글은 잘되고있는 사업은 확실하게 밀어주지만 잘되지 않고 있는 사업에 관해서는 확실히 끊어버리기에 Dart만 배워서 먹고살려고 한다면 조심해야한다고 할수있겠다. 마치며하나의 코드로 여러 플랫폼에서 구동할 수 있는것은 매력있고 효율적으로 보이지만 아직까지는 한계적인 부분이 많다. 운영체제, 하드웨어 별로 차이로 인해 크로스 플랫폼을 기반으로 소프트웨어를 개발할경우 운영체제들이 공통으로 지원하는 기능만을 사용해야 한다. 지금은 아니지만 마치 IE를 대응하는 것과 같은거인가? 앞으로의 개발방향에 있어 Native와 관련된 것들도 살펴보아야겠다. 참조 https://www.newiki.net/wiki/크로스_플랫폼 이미지참조","link":"/2021/04/03/CrossPlatform/"},{"title":"RSS란?","text":"RSS = Real Simple Syndication - 진짜 심플한 배급 or Rich Site Summary - 풍부한 사이트 요약 예를 들어봅시다!관심있는 유튜브를 매일 방문해서 재미있는 새로운 콘텐츠가 있는지는 확인하기 번거롭습니다. 특히 정기적으로 게시물이 올라오지 않는경우에는 더욱 그렇습니다. 그 사이트를 직접 방문하지 않고 새로운 콘텐츠가 올라왔을경우만 본인의 컴퓨터로 전달이 된다면 편리할것입니다. - 일종의 알림설정처럼 RSS는 새로운 기사들의 제목이나 글의 전체를 뽑아 하나의 파일로 만들어 놓은것입니다. (XML 형식) 이제 각 사이트에서 제공하는 RSS 파일 주소만 수집하여 확인하면 자신의 취향에 맞는 새로운 정보를 쉽게 찾아 읽을수있습니다. 모든 사이트에서 RSS가 사용되는것은 아니고 주로 새로운 내용이 없는 정적인 사이트에 제공하지 않고 블로그나 뉴스형 사이트에서 주로 제공됩니다. RSS 피드 주소를 얻어 RSS리더기에 주소를 넣어 구독을 하게되면 RSS리더기가 자동으로 알려주고 보여주게됩니다. 쉽게 이해하자면 RSS피드 주소는 게시물을 올리는 유튜버의 고유주소, RSS리더기는 구독+알림설정 정도가 되겠습니다. RSS의 장점 예를 들어 블로그 같은경우 email을 입력해 구독을 권장하는 경우가 있는데 이러한경우 개인정보 유출의 위험이 있다. 하지만 RSS 피드를 사용해서 구독한다면 신뢰하지 못하는 사이트의 경우에도 어떠한 정보를 알려줄 필요가 없기에 안전하다. 참조 [꿀팁] 초보자를 위한 RSS 란? RSS의 뜻과 의미는? 레알! 쉽게 이해할 수 있음 RSS - 위키백과","link":"/2021/03/31/RSS%EB%9E%80/"},{"title":"ThirdParty","text":"서드파티?하드웨어 생산자와 소프트웨어 개발자의 관계를 나타내는 용어로 사용된다. 하드웨어 생산자는 퍼스트파티(first party) 소프트웨어 개발자는 서드파티(third party) 123하드웨어 생산자가 **직접** 소프트웨어를 개발한다면? → **퍼스트 파티**하드웨어 생산자인 모기업과 자사관계로 소프트웨어 개발을한다 → **세컨드 파티**하드웨어 생산자인 모기업과 자사관계, 하청관계 전혀 관련없는 소프트웨어 개발 → **써드 파티** 프로그래밍 관점프로그래밍에서의 서드 파티라는 것은 편한 개발을위해 플러그인 이나 library 혹은 프레임워크를 사용하는데 이처럼 제 3자로써 중간다리 역할을 하는 것을 서드파티라고 한다. 또한 이런것들을 만드는 개발자가 서드 파티 개발자다. 즉, 제 3자가 만든 라이브러리로써 개인 개발자나 프로젝트 팀, 혹은 업체등에서 개발하는 라이브러리를 뜻하기도한다. 또한 프로그래밍 개발과 개발자 사이에 플러그인, 라이브러리 프레임 워크를 서드 파티로 볼수있다. 참조 위키백과 gyoogle 이미지참조","link":"/2021/04/07/ThirdParty/"},{"title":"VanilaJS-Array","text":"자료구조상의 배열은 동일한 크기의 메모리공간이 빈틈없이 연속되는 자료구조를 뜻하며, 하나의 데이터타입을 가지고 있는것을 뜻하며 이는 밀접배열이라한다. 이러한 배열은 정렬되어있는 상태라면 접근하여 값을 찾는경우 매우빠르게 동작하겠지만, 그렇지 않은 경우에는 정렬시간과 값을 찾는시간이 더해져 효율적이지 못하게된다. 자바스크립트의 배열은 메모리공간이 동일한 크기를 가지지 않아도 되며, 연속되지 않을수있다. 자바스크립트에서 배열의 구조가 연속적으로 이어져 있지 않은 배열은 희소배열이라한다. 자바스크립트의 배열은 사실 객체이다. 자료구조상의 배열을 흉내낸 해시테이블 구조를 가진 객체이며, 배열 안의 요소는 element라고 불리운다. 배열은 자신의 위치를 나타내는 0 이상의 정수인 index를 가진다. 배열은 요소의 개수를 나타내는 length 프로퍼티를 가진다. 배열의 인덱스는 사실 프로퍼티키이며, 문자열이다. “일반 객체와 배열을 구분하는 가장 명확한 차이는 index(값의 순서)와 length 프로퍼티가 있다는 점이다.” length 프로퍼티 그리고 희소배열length 프로퍼티는 요소의 개수 즉, 배열의 길이를 나타낸다. 빈 배열일경우에는 0이며 아닐경우 가장 큰 인덱스에 1을 더한것과 같다. 12console.log([].length); // 0console.log([1, 2, 3, 4].length); // 4 희소배열은 length프로퍼티가 배열이 가진 요소의 개수보다 크고, 일부가 비어 있는 배열을 희소 배열이라고 할수있다. 123const arr = [1, 2, 3];arr.length = 100;console.log(arr); // (100) [1, 2, 3, empty × 97] 배열의 생성방식 배열리터럴 가장 기본적인 배열 생성 방식이다. 1const arr = []; // 배열리터럴 Array 생성자함수 전달된 인수가 2개 이상이거나 숫자가 아닌경우 인수를 요소로 갖는 배열이 생성된다. 이때 숫자를 넣게되면 희소배열이 만들어진다. new 연산자와 함께 호출하지 않아도 Array 생성자 함수내의 new.target에 의해 생성자함수로 동작한다. 12345const arr1 = new Array('얍');console.log(arr1); // ['얍']const arr2 = new Array(10);console.log(arr2); // (10) [empty × 10] Array.of( ) 전달된 인수가 숫자이고 1개여도 배열이 만들어진다. 12const arr = Array.of(1);console.log(arr); // [1] Array.from( ) 유사배열객체와 이터러블을 인수로 전달받아 배열로 변환해 반환한다. 123const foo = 'hello';const result = Array.from(foo);console.log(result); // (5) [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] 배열의 요소참조배열의 요소참조는 [] 대괄호 표기법을 이용해 이루어지며, 대괄호 안에는 인덱스가 와야하며, 정수로 평가되는 표현식도 인덱스 대신 사용이 가능하다. 배열의 인덱스는 프로퍼티 키이며 존재하지 않는 프로퍼티로 객체의 프로퍼티에 접근했을경우 undefied를 반환하는것처럼 배열에서도 동일하게 작동된다. 12const arr = [1, 2, 3];console.log(arr[3]); //undefined 배열 메서드배열메서드는 원본배열을 변경하는 메서드, 원본배열을 변경하지 않는 메서드 두가지로 나뉜다. 사용빈도가 비교적 높고 대표적인 배열메서드를 알아보자. Array.isArray( ) 인수로 전달된 값이 배열인지 아닌지를 확인하는 메서드이다. 반환되는 데이터타입은 boolean이다. 12345const arr1 = [1, 2, 3];const arr2 = {};console.log(Array.isArray(arr1)); // trueconsole.log(Array.isArray(arr2)); // false Array.prototype.indexOf( ) 인수로 전달된 요소를 검색해 인덱스를 반환한다. 만약 중복되는 요소가 있다면 첫번째로 검색된요소의 인덱스를 반환한다. 원본배열에 인수로 전달된 요소가 존재하지 않으면 -1을 반환한다. 두번째 인수는 검색을 시작할 인덱스이며 생략시 처음부터 검색한다. 12const arr = [1, 2, 3];console.log(arr.indexOf(2)); // 1 Array.protorype.push( ) 인수로 전달받은 값을 원본배열의 마지막요소로 추가한다. 반환되는 값은 원본배열의 length 프로퍼티이다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.push(4);console.log(arr); // [1, 2, 3, 4]console.log(result); // 4 원본배열을 훼손하는 행위는 권장하지 않는다. 그렇기에 ES6에서 추가된 스프레드 문법을 활용하는것이 바람직하다. ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [...arr, 4];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] Array.prototype.pop( ) 원본 배열의 마지막요소를 제거한다 제거된 요소를 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.pop();console.log(arr); // (2) [1, 2]console.log(result); // 3 Array.prototype.unshift( ) 원본배열의 선두요소에 인수로 전달받은 값을 추가한다. 반환되는 값은 원본배열의 length 프로퍼티이다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.unshift(4);console.log(arr); // (4) [4, 1, 2, 3]console.log(result); // 4 원본배열을 훼손하는 행위는 권장하지 않는다. 그렇기에 ES6에서 추가된 스프레드 문법을 활용하는것이 바람직하다. ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [4, ...arr];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [4, 1, 2, 3] Array.prototype.shift( ) 원본배열에서 첫번째 요소를 제거한다. 제거된 요소를 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.shift();console.log(arr); // (2) [2, 3]console.log(result); // 1 Array.prototype.concat( ) 원본배열의 마지막에 인수로 전달받은 값을 추가한다. ( 전달된 값이 배열이면 해체하여 새로운 배열의 요소로 추가한다. ) 변경된 새로운 배열을 반환한다. 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.concat(4);console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [...arr, 4];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] Array.prototype.splice( StartIndex, deleteCount, [item]) 원본배열의 중간에 요소를 추가 혹은 제거한다. StartIndex - 원본배열의 요소를 제거하기 시작할 인덱스 ( StartIndex만 지정하면 모든 요소제거 ) deleteCount - 원본배열의 요소를 제거할 개수 ( 0 이면 어느것도 제거되지 않는다. ) item - 원본배열의 요소를 제거한 위치에 삽일할 요소들의 목록 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.splice(1, 2, 3, 4);console.log(arr); // (3) [1, 3, 4]console.log(result); // (2) [2, 3] Array.prototype.slice( StartIndex, EndIndex ) 인수로 전달된 범위의 요소를 복사한다. 원본배열을 복사한 배열을 반환한다. ( 인수를 모두 생략하면 원본배열의 복사본을 생성해 반환한다. ) StartIndex - 원본배열의 복사를 시작할 인덱스 ( 음수일경우는 맨 마지막 요소에서 -n 이후의 값을 반환 ) EndIndex - 원본배열의 복사를 종료할 인덱스 ( 해당요소는 미포함 , 기본값은 length 프로퍼티 값 ) 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.slice(1, 2);console.log(arr); // (3) [1, 2, 3]console.log(result); // [2] Array.prototype.join( ) 원본배열의 모든요소를 문자열로 변환한다. 인수로 전달받은 값( 구분자 )으로 연결한 문자열을 반환한다. 기본 구분자는 콤마이다. , 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.join('');console.log(arr); // (3) [1, 2, 3]console.log(result); // 123 Array.prototype.reverse( ) 원본배열의 순서를 반대로 뒤집는다. 변경된 원본배열을 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.reverse();console.log(arr); // (3) [3, 2, 1]console.log(result); // (3) [3, 2, 1] Array.prototype.fill( _ , StartIndex, StopIndex ) ES6 인수로 전달 받은 값을 배열의 요소로 처음부터 끝까지 채운다. _ - 배열을 채울 요소 StartIndex - 요소를 채우기 시작할 인덱스 StopIndex - 요소를 채우는것을 멈출인덱스 ( 해당 요소는 미포함 ) 원본배열을 변환시킨다. 12345const arr = new Array(10);const result = arr.fill(1, 2, 10);console.log(arr); // (10) [empty × 2, 1, 1, 1, 1, 1, 1, 1, 1]console.log(result); // (10) [empty × 2, 1, 1, 1, 1, 1, 1, 1, 1] Array.prototype.includes( SearchElement, StartIndex ) ES7 원본 배열에 특정요소가 포함되어있는지 확인한다. true 혹은 false를 반환한다. SearchElement - 검색할 대상지정 StartIndex - 검색을 시작할 인덱스 12345const arr = [1, 2, 3];const result = arr.includes(2, 1);console.log(arr); // (3) [1, 2, 3]console.log(result); // true Array.prototype.flat( ) ES10 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다. 기본값은 1단계 평탄화이다. Infinity를 인수로 전달하면 중첩배열을 모두 평탄화한다. 1234console.log([1, [2, 3, 4, 5]].flat()); // (5) [1, 2, 3, 4, 5]console.log([1, [2, [3, 4, 5]]].flat(1)); // (5) [1, 2, 3, 4, 5]console.log([1, [2, [3, [4, 5]]]].flat(2)); // (4) [1, 2, 3, Array(2)]console.log([1, [2, [3, [4, [5]]]]].flat(Infinity)); // (5) [1, 2, 3, 4, 5]","link":"/2021/04/02/VanilaJS-Array/"},{"title":"VanilaJS-HOF","text":"배열고차함수 (Array Higher Order Function in JS) 고차함수(Higher-Order-Function)는 함수를 인수로 전달받거나 반환하는 함수를말한다. 자바스크립트에서 활용도가 매우높은 배열에사용되는 고차함수에 대해 알아보자. Array.prototype.sort( ) 원본배열의 요소를 정렬한다. ( 기본적으로 오름차순으로 요소를 정렬한다. ) 정렬된 배열을 반환한다. 원본배열이 변환된다. 12345const arr = [1, 3, 5, 20, 11];const result = arr.sort();console.log(arr);) // [1, 11, 20, 3, 5]console.log(result); // [1, 11, 20, 3, 5] 필자는 “sort 메서드를 따로 분류해서 페이지를 만들까?” 까지 고민할정도로 중요하고 또 어렵게 느껴졌다. 좀더 자세히 sort 메서드에 대해 알아보자. sort 메서드는 배열안의 요소에 따라 다르게 동작한다. 문자열로 이루어진 배열의 경우 숫자로 이루어진 배열의 경우 sort 메서드는 숫자로 이루어진 배열의 요소들을 일시적으로 문자열로 변환시켜 유니코드의 순서를 기준으로 정렬한다. 먼저 유니코드(Unicode)에 관해서 간단하게 설명한다면, 컴퓨터에서 사용되는 모든기호나 문자들에 관해서 컴퓨터가 이해할수있게 만들어 놓은 표기방식이라고 할수있겠다. sort메서드는 유니코드를 기준으로 배열안의 요소들을 정렬하게 되는데 기존에 문자열 같은경우는 우리가 알고있는 알파벳순서에 따라 정상적으로 잘 동작한다. 12345const fruits = ['Apple', 'Orange', 'Banana', 'Peach', 'Grape'];const result = fruits.sort();console.log(fruits); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Grape&quot;, &quot;Orange&quot;, &quot;Peach&quot;]console.log(result); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Grape&quot;, &quot;Orange&quot;, &quot;Peach&quot;] 하지만, 숫자 같은 경우 조금 다르다. 12345const arr = [1, 3, 5, 20, 11];const result = arr.sort();console.log(arr);) // [1, 11, 20, 3, 5]console.log(result); // [1, 11, 20, 3, 5] 위 예시처럼 숫자같은경우는 11과 20이 3과 5보다 먼저 정렬된다. 이는 유니코드 표기법에 의해 정렬되었기 때문이다. 즉, 숫자에서 일시적으로 문자로 변환된 문자열들을 유니코드를 기준으로 비교하면 문자열 ‘11’이 ‘20’, ‘3’, ‘5’ 보다 더 앞서기 때문이다. 비교함수 전달하기따라서 숫자요소를 정렬할때는 특별히 비교함수를 sort 메서드 안으로 전달해야한다. 0을 기준으로 오름차순과 내림 차순이 결정된다. 반환되는 값이 0 이상이면 오름차순 ( 0 &lt; returnValue ) - 첫번째 인수를 우선으로 하여 정렬 반환되는 값이 0 이면 정렬하지 않음 반환되는 값이 0 이하면 내림차순 ( 0 &gt; returnValue ) - 두번째 인수를 우선으로 하여 정렬 오름차순정렬 12345678const arr = [3, 10, 21, 14, 5];const compare = (next, prev) =&gt; { return next - prev;};const result = arr.sort(compare);console.log(arr); // (5) [3, 5, 10, 14, 21]console.log(result); // (5) [3, 5, 10, 14, 21] 내림차순정렬 12345678const arr = [3, 10, 21, 14, 5];const compare = (next, prev) =&gt; { return prev - next;};const result = arr.sort(compare);console.log(arr); // (5) [21, 14, 10, 5, 3]console.log(result); // (5) [21, 14, 10, 5, 3] 위 코드의 compare 매개 변수의 이름을 잘보면 next, prev 라고 명시했다. 이는 sort 메서드 내부동작의해서 원본배열의 secondIndex가 next로 들어가고 firstIndex가 prev로 들어가기에 이렇게 작성했다. 필자는 이것을 알아내느라 하루를 소모했다..😂 sort 메서드 관련 좀더 자세한 사항은 아래의 이곳, 저곳, 요곳을 참조하면된다! 유니코드 관련 참조사이트 https://ko.wikipedia.org/wiki/유니코드 https://d2.naver.com/helloworld/19187 https://graphemica.com/ https://unicode-table.com/kr/#basic-latin Array.prototype.forEach((currentValue, index, arr), [thisArg]) for문을 대체할수 있는 고차함수이다. 자신을 호출한 배열의 모든요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. forEach 문의 반환값은 언제나 undefined이다. 원본배열을 변경하지않는다. 12345const numbers = [1, 2, 3, 4, 5];const result = numbers.forEach((number) =&gt; number * 2);console.log(numbers); // (5) [1, 2, 3, 4, 5]console.log(result); // undefined forEach문은 원본 배열을 변경하지 않지만, 콜백함수를 통해 원본 배열을 변경할수는 있다. 12345678910const numbers = [1, 2, 3, 4, 5];const result = numbers.forEach((number, index, arr) =&gt; { console.log(number); // 1 2 3 4 5 console.log(index); // 0 1 2 3 4 console.log(arr); // [2, 2, 3, 4, 5] ··· 순회시마다 원본배열은 변화 return (arr[index] = number * 2);});console.log(numbers); // (5) [2, 4, 6, 8, 10]console.log(result); // undefined 콜백함수의 3번째 인수로 전달된 원본배열을 index로 직접 참조해서 값을 변경하는것이 가능하다. 콜백함수안으로 this의 전달과 그 이유forEach 메서드의 두번째 인수로 this로 사용할 객체를 전달할수있다. 1234567891011121314class Numbers { numberArray = []; multiply(arr) { arr.forEach(function (elem) { this.numberArray.push(elem * elem); }, this); console.log(this); // Numbers {numberArray: Array(3)} }}const arr = new Numbers();arr.multiply([1, 2, 3]);console.log(arr.numberArray); // (3) [1, 4, 9] 이는 일반함수로 호출한 this의 값은 전역객체(window)를 가르키기에 콜백함수내에서 사용될 this의 값과 고차함수의 몸체안에서의 this와 일치시키기 위함이다. class함수 내에서 this를 전달하지 않는다면 typeError: Cannot read property ‘numberArray’ of undefined가 발생하는데 이는 클래스 내부의 모든 코드에는 암묵적으로 strictmode가 적용되기 떄문이다. 다시말해, class함수 내에서 strictmode(엄격모드)가 적용될때 this가 전역객체(window)를 가리키는것은 this의 사용이유(자신이 속한 위치를 나타내는것)가 적절하지 못하기때문에 undefined를 반환하게된다. 보통 ES6 이후부터는 화살표함수(자체적인 this를 가지지 않는다.)를 사용함으로써 상위 스코프의 this를 가르키게끔 하여 이러한 문제를 해결한다. 그리고 forEach문은 break, continue문을 사용할수 없으며, 배열의 모든 요소를 순회한다. Array.prototype.map((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값들로 구성된 새로운 배열을 반환한다. 콜백함수의 반환값이 map메서드를 호출한 배열의 요소를 1 : 1 매핑한다. 원본배열이 변환되지 않는다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.map((v, i, arr) =&gt; v * 2);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // (5) [2, 4, 6, 8, 10] Array.prototype.map 메서드는 메서드를 호출한 배열의 각각의 요소값을 다른 값으로 매핑하여 새로운 배열을 생성하기 위해 사용한다. Array.prototype.filter((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다. 원본배열이 변환되지 않는다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.filter((v, i, arr) =&gt; v &lt; 2);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // [1] Array.prototype.filter 메서드는 메서드를 호출한 각각의 요소값들중 콜백함수로 전달한 조건에 만족하는(반환값이 true) 요소로 이루어진 배열을 반환한다. Array.prototype.reduce((accumulator, currentValue, index, arr), [InitialValue]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값을 다음순회시에 콜백함수의 첫째인수로 전달한다. 하나의 결과값을 반환한다. 원본배열이 변환되지 않는다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.reduce((acc, cur, index, arr) =&gt; acc + cur, 0);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // 15 Array.prototype.reduce 메서드는 메서드를 호출한 각각의 요소값들중 콜백함수로 전달된 초기값(initialValue)과 계산식을 가지고 배열의 요소를 계산하여 반환되는 값을 콜백함수의 첫번째 인수(acc)로 넘겨주면서 호출한다. 즉, 값을 계속 누산하여 하나의 결과값을 반환한다. reduce메서드의 초기값 전달과 그 이유1234567891011121314const arr = [1, 2, 3, 4, 5];const result = arr.reduce((acc, cur, index, arr) =&gt; acc + cur, 0);/* acc + cur 0 + 1 1 + 2 3 + 3 6 + 4 10 + 5*/console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // 15 이때, reduce 메서드의 두번째 인수로 전달하는 초기값은 첫번째 순회에 콜백함수의 첫번째 인수로 전달된다. 그래서 위 예제의 첫번째 순환값은 1이다. reduce메서드의 두번째 인수로 전달되는 초기값은 옵션이지만 생략하지 않는것이 좋다. 이는 reduce메서드를 호출하는 배열이 빈배열일 경우에 에러발생이 일어나는것을 방지할수있다. 123456const arr = [];const result = arr.reduce((acc, cur, index, arr) =&gt; acc + cur);/* Uncaught TypeError: Reduce of empty array with no initial value */console.log(arr);console.log(result); 또한 객체의 특정 프로퍼티값을 합산하는 경우에는 반드시 초기값을 전달해야한다. 12345678910111213141516const goods = [ { id: 1, price: 300 }, { id: 2, price: 500 }, { id: 3, price: 700 },];/* acc + cur 300 + 500 800.price? + 700 NaN*/const result = goods.reduce((acc, cur, index, arr) =&gt; acc.price + cur.price);console.log(goods); // (3) [{…}, {…}, {…}]console.log(result); // NaN 위의 식은 acc.price + cur.price 인데 아래의식은 acc + cur.price 인 이유는 위의 식은 값을 숫자값들을 더하기위해 어쩔수 없이 작성하였지만, 아래의 식은 초기값을 전달하면서 첫번째 순회시 acc의 값이 0으로 전달되기에 acc + cur.price 만으로 얻고싶은 값을 얻어낼수있다. 1234567891011121314151617const goods = [ { id: 1, price: 300 }, { id: 2, price: 500 }, { id: 3, price: 700 },];/* acc + cur 0 + 300 300 + 500 800 + 700 1500*/const result = goods.reduce((acc, cur, index, arr) =&gt; acc + cur.price, 0);console.log(goods); // (3) [{…}, {…}, {…}]console.log(result); // 1500 reduce에 대한 더 많은 활용법과 예제는 이곳을 참고하자😁 Array.prototype.some((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 단 한번이라도 참이면 true, 모두 거짓이면 false를 반환한다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.some((v, i, arr) =&gt; v &gt; 4);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // true Array.prototype.some메서드는 메서드를 호출한 배열의 요소중 콜백함수에서 정의한 조건을 만족하는 요소가 단 한개라도 존재한다면 true를 반환한다. 단, 메서드를 호출한 배열이 빈배열일 경우는 false를 반환한다. Array.prototype.every((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 모두 참이면 true, 단 하나라도 거짓이면 false를 반환한다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.every((v, i, arr) =&gt; v &gt; 4);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // false Array.prototype.every메서드는 메서드를 호출한 배열의 모든 요소들이 콜백함수에서 정의한 조건을 만족한다면 true를 반환한다. Array.prototype.find((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 true인 첫번째 요소를 반환한다. true인 요소가 존재하지 않는경우 undefined를 반환한다. 1234567891011const ranking = [ { id: 1, color: 'green' }, { id: 2, color: 'red' }, { id: 3, color: 'blue' }, { id: 4, color: 'yellow' }, { id: 5, color: 'blue' },];const result = ranking.find((v, i, arr) =&gt; v.color === 'blue');console.log(result); // {id: 3, color: &quot;blue&quot;} Array.prototype.find메서드는 메서드를 호출한 배열의 요소들중 콜백함수로 정의한 조건에 만족하는 첫번째 요소를 반환한다. Array.prototype.findIndex((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 true인 첫번째 요소의 인덱스를 반환한다. 반환값이 true인 요소가 없다면 -1을 반환한다. 1234567891011const ranking = [ { id: 1, color: 'green' }, { id: 2, color: 'red' }, { id: 3, color: 'blue' }, { id: 4, color: 'yellow' }, { id: 5, color: 'blue' },];const result = ranking.findIndex((v, i, arr) =&gt; v.color === 'blue');console.log(result); // 2 Array.prototype.findIndex메서드는 메서드를 호출한 배열의 요소들중 콜백함수로 정의한 조건에 만족하는 첫번째 요소의 인덱스를 반환한다. 추가적인 배열 메서드와 관련해서는 이곳을 참고하길 바란다.","link":"/2021/04/02/VanilaJS-HOF/"}],"tags":[{"name":"Technical Terms","slug":"Technical-Terms","link":"/tags/Technical-Terms/"},{"name":"CrossPlatform","slug":"CrossPlatform","link":"/tags/CrossPlatform/"},{"name":"RSS","slug":"RSS","link":"/tags/RSS/"},{"name":"ThirdParty","slug":"ThirdParty","link":"/tags/ThirdParty/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"forEach","slug":"forEach","link":"/tags/forEach/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"filter","slug":"filter","link":"/tags/filter/"},{"name":"reduce","slug":"reduce","link":"/tags/reduce/"},{"name":"some","slug":"some","link":"/tags/some/"},{"name":"every","slug":"every","link":"/tags/every/"},{"name":"find","slug":"find","link":"/tags/find/"},{"name":"findIndex","slug":"findIndex","link":"/tags/findIndex/"}],"categories":[{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"Technical Terms","slug":"CS/Technical-Terms","link":"/categories/CS/Technical-Terms/"},{"name":"Array","slug":"JS/Array","link":"/categories/JS/Array/"}]}