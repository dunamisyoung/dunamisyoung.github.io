{"pages":[{"title":"about","text":"👨‍💻 안녕하세요 Asher입니다! 👨‍💻2019년 7월 쇼핑몰 창업을위해 웹디자인공부로 시작했던 공부가 현재는 FE 개발자가 되기위해 부단히 노력하고있습니다 :)미흡하거나 부족한 점이 많아 조언해주고 싶으신 부분이 있다면 댓글로 남겨주세요!방문해주셔서감사합니다😁 In his heart a man plans his course, but the LORD determines his steps. (Proverbs 16:9)","link":"/about/index.html"}],"posts":[{"title":"API","text":"API란?API 라는 말을 개발공부를 하다보면 자주 접하게되는데 사실 이에 대한 명확한 이해를 하지 못하고 공부를 하였던거 같아서 이제는 용어에 대해 정리 해보려고한다. “API(Application Programming Interface 애플리케이션 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터 페이스를 뜻한다.” 주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공한다. - 위키백과 API를 알기전에 UI(User Interface)를 먼저 짚어보자면, 우리가 실생활 에서 자주 사용하는 스마트 폰을 예를 들어보자. 스마트 폰의 홈버튼을 보면 Photo by Tyler Nix on Unsplash 이 홈버튼(UI, 사용자 환경)은 사용자가 홈화면으로 돌아가게끔 해주는 방법이며 수단이다. 즉, 스마트폰과 사용자를 이어주는 매개체 이다. API도 같은 맥락으로 UI가 사용자와 사용자가 다룰 대상(하드웨어 혹은 소프트웨어)를 연결한다면 API는 프로그램과 또 다른 프로그램을 연결해주는 일종의 다리라고 볼 수 있다. 예를들어, 나의 포트폴리오를 만들고자할때 아래의 3가지의 큰 주제로 만들어보려고한다. 일기예보 - 일기 예보 정보 자신이 만든 웹페이지에 띄우려면? 지도 - 지도를 이용한 웹서비스를 제작하려면? 결제 - 사용자들로부터 결제를 통해 나의 앱을 사용하게끔 하려면? 보통 일반 사람들은 이러한 큰 데이터들을 가지고 있지 않을뿐더러 관련 프로그램도 가지고 있지 않다. 하지만, 인터넷상에서 제공되는 API를 이용한다면 충분히 가능하게된다. “*API(Application Programming Interface 애플리케이션 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터 페이스를 뜻한다.*“ 주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공한다. 응용프로그램 ⇒ 나의 포트폴리오 운영체제나 프로그래밍 언어가 제공하는 기능 ⇒ 날씨정보, 지도정보, 카카오페이 등등.. 결론 : API란 간단히 하자면 내가 만든 프로그램이 개인 개발자, 기업 기관이 제공하는 기능, 프로그램 등을 활용할 수 있게끔 도와주는 중간 매개체 라는 것이며, 공공 API 유용한 무료 API들이 존재한다. API의 역할? 서버와 데이터베이스에 대한 출입구 역할을 한다. 데이터베이스에 존재하는 중요한 데이터들을 보안하기위해 허용된 사용자에게만 접근하게끔함 애플리케이션과 기기가 원할하게 통신 할 수 있도록한다. 스마트폰 어플이나 프로그램이 기기와 데이터를 원할이 주고받게끔함 모든 접속을 표준화 한다. 기계 / 운영체제와 관련없이 동일한 액세스를 얻을수 있다. (액세스 - 기억 장치의 특정 장소나 데이터 및 프로그램 따위에 사용자나 사용자 그룹이 접근하거나 수행할 수 있는 권리의 범위.) API의 유형? private API - 회사 내부 API로 자체 제품서비스를 개선하기위해 내부적으로 발행 public API - 공공 API로 누구나 제한없이 사용가능 partner API - 기업이 동의하는 특정인들만 사용이 가능 참고 api란? API란? 비개발자가 알기 쉽게 설명해드립니다! 읽어보면 좋은글 및 이미지 참조","link":"/2021/04/07/API/"},{"title":"CrossPlatform","text":"크로스 플랫폼?크로스 플랫폼 (영어: cross-platform) 또는 멀티 플랫폼 (영어: multi-platform)은 컴퓨터 프로그램, 운영 체제, 컴퓨터 언어, 프로그래밍 언어, 컴퓨터 소프트웨어 등이 여러 종류의 컴퓨터 플랫폼에서 동작할 수 있다는 것을 뜻하는 용어이다. - 위키백과 예를 들어보자. 대중적으로 많이 사용하고 있는 IDE(통합개발환경) 인 비주얼 스튜디오 코드는 마이크로소프트사인 윈도우는 물론, 맥, 리눅스 환경에서도 잘동작한다. 각자 키보드나 디렉터리 구조 차이 같은 것들이 있긴하지만 어떤 운영체제에서도 비슷하게 사용이가능하다. 이는 비주얼 스튜디오 코드가 크로스 플랫폼 프레임 워크인 일렉트론을 기반으로 하고 있기 때문이다. 이처럼 여러종류의 컴퓨터 플랫폼(MAC OS, Linux, Window)에서 동작 할 수 있는 것을 의미한다. 웹 그리고 모바일 시장의 크로스 플랫폼과 네이티브현재 IT 시장에서 서비스를 출시할경우 앱이 없어서는 안되는 경우가 대부분이다. 웹 뿐만아니라 모바일 소프트 웨어 업계에서도 최근에 크로스 플랫폼 바람이 불고있다. 이는 개발자들이 Android 와 iOS 에 대응하는 각각의 어플리케이션을 중복적으로 개발하지 않고 양쪽 OS에 대응하는 앱을 만들수 있기때문이다. 또한 앱개발에 필요한 개발자가 줄어들기에 소스 코드 관리가 편해질수있다. 크로스 플랫폼의 종류 ReactNative - facebook 자마린 - microsorft Flutter - Google 이러한 크로스플랫폼들을 사용하기 위해서는 결국 Native와 관련된 지식과 기술들이 필요하다고 한다. 하지만 구글에서 Flutter 라는 크로스 플랫폼을 만들었는데 이는 기존의 Native UI를 무시하고 사용할수 있다고한다. 하지만 Dart라는 언어를 배워야한다는 것과, 구글은 잘되고있는 사업은 확실하게 밀어주지만 잘되지 않고 있는 사업에 관해서는 확실히 끊어버리기에 Dart만 배워서 먹고살려고 한다면 조심해야한다고 할수있겠다. 마치며하나의 코드로 여러 플랫폼에서 구동할 수 있는것은 매력있고 효율적으로 보이지만 아직까지는 한계적인 부분이 많다. 운영체제, 하드웨어 별로 차이로 인해 크로스 플랫폼을 기반으로 소프트웨어를 개발할경우 운영체제들이 공통으로 지원하는 기능만을 사용해야 한다. 지금은 아니지만 마치 IE를 대응하는 것과 같은거인가? 앞으로의 개발방향에 있어 Native와 관련된 것들도 살펴보아야겠다. 참조 https://www.newiki.net/wiki/크로스_플랫폼 이미지참조","link":"/2021/04/03/CrossPlatform/"},{"title":"AWS","text":"AWS? 그리고 서비스형 플랫폼, 클라우드 컴퓨팅아마존 웹 서비스(영어: Amazon Web Services; AWS)는 아마존닷컴의 클라우드 컴퓨팅 사업부다. 아마존 웹 서비스는 다른 웹 사이트나 클라이언트측 응용 프로그램에 대해 온라인 서비스를 제공하고 있다. 이러한 서비스의 상당수는 최종 사용자에 직접 공개되는 것이 아니고, 다른 개발자가 사용 가능한 기능을 제공하는 플랫폼을 제공하는 PaaS이다. - 위키백과 PasS(서비스형 플랫폼)?서비스형 플랫폼(PaaS)인 AWS는 개발자가 사용자에게 웹서비스나 앱서비스를 개발하기위해 모든 프로그램들을 구축하고 유지하는 복잡함 없이 AWS(PasS)에서 제공하는 플랫폼을 이용해 마치 오픈 API와 같이 사용하며 애플리케이션을 개발, 실행, 관리 할 수 있게 하는 것을 말한다고 할수있다. 즉, 개발을 위한 플랫폼을 구축할 필요 없이, 필요한 개발요소를 웹에서 쉽게 빌려쓸수 있게 하는 모델이다. 서비스형 플랫폼(Platform as a Service, PaaS)은 클라우드 컴퓨팅 서비스 분류 중 하나다. - 위키백과 클라우드 컴퓨팅? 쉽게 말하면 클라우드 컴퓨팅은 인터넷(“클라우드”)을 통해 서버, 스토리지, 데이터베이스, 네트워킹, 소프트웨어, 분석, 인텔리전스 등의 컴퓨팅 서비스를 제공하는 것입니다. - Microsoft Azure 클라우드 컴퓨팅은 IT 리소스를 인터넷을 통해 온디맨드로 제공하고 사용한 만큼만 비용을 지불하는 것을 말합니다. 물리적 데이터 센터와 서버를 구입, 소유 및 유지 관리하는 대신, Amazon Web Services(AWS)와 같은 클라우드 공급자로부터 필요에 따라 컴퓨팅 파워, 스토리지, 데이터베이스와 같은 기술 서비스에 액세스할 수 있습니다. - amazon 즉, 클라우드 컴퓨팅은 IT리소스(자원)를 인터넷을 통해 소비자의 수요에 따라 즉각적으로 제공하고 사용한만큼만 비용을 지불하는 방식으로, 사용자가 인터넷(“클라우드”)을 통해 서버사용, 대용량저장소 사용, 데이터베이스 사용등을 할수 있게 서비스를 제공하는 것이라고 할수있다. 결론AWS는 클라우드컴퓨팅을 제공하는 서비스형 플랫폼으로 사업가와 개발자가 웹서비스를 사용하여 확장가능하고 정교한 애플리케이션을 구축하도록 지원하는 서비스이다. 현재로써는 가볍게 이정도로 마무리하고 다음에는 애플리케이션 배포에 대해 알아봐야겠다. 참조 https://goddaehee.tistory.com/174","link":"/2021/04/11/AWS/"},{"title":"RSS란?","text":"RSS = Real Simple Syndication - 진짜 심플한 배급 or Rich Site Summary - 풍부한 사이트 요약 예를 들어봅시다!관심있는 유튜브를 매일 방문해서 재미있는 새로운 콘텐츠가 있는지는 확인하기 번거롭습니다. 특히 정기적으로 게시물이 올라오지 않는경우에는 더욱 그렇습니다. 그 사이트를 직접 방문하지 않고 새로운 콘텐츠가 올라왔을경우만 본인의 컴퓨터로 전달이 된다면 편리할것입니다. - 일종의 알림설정처럼 RSS는 새로운 기사들의 제목이나 글의 전체를 뽑아 하나의 파일로 만들어 놓은것입니다. (XML 형식) 이제 각 사이트에서 제공하는 RSS 파일 주소만 수집하여 확인하면 자신의 취향에 맞는 새로운 정보를 쉽게 찾아 읽을수있습니다. 모든 사이트에서 RSS가 사용되는것은 아니고 주로 새로운 내용이 없는 정적인 사이트에 제공하지 않고 블로그나 뉴스형 사이트에서 주로 제공됩니다. RSS 피드 주소를 얻어 RSS리더기에 주소를 넣어 구독을 하게되면 RSS리더기가 자동으로 알려주고 보여주게됩니다. 쉽게 이해하자면 RSS피드 주소는 게시물을 올리는 유튜버의 고유주소, RSS리더기는 구독+알림설정 정도가 되겠습니다. RSS의 장점 예를 들어 블로그 같은경우 email을 입력해 구독을 권장하는 경우가 있는데 이러한경우 개인정보 유출의 위험이 있다. 하지만 RSS 피드를 사용해서 구독한다면 신뢰하지 못하는 사이트의 경우에도 어떠한 정보를 알려줄 필요가 없기에 안전하다. 참조 [꿀팁] 초보자를 위한 RSS 란? RSS의 뜻과 의미는? 레알! 쉽게 이해할 수 있음 RSS - 위키백과","link":"/2021/03/31/RSS%EB%9E%80/"},{"title":"TDD","text":"TDD?요즘 개발자 관련글들에서 TDD라는 용어가 많이보인다. ( 21/3월 기준 ) 그렇다면 TDD가 뭔지 알아보도록하자:) *테스트 주도 개발(Test-driven Development, TDD)*은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스중 하나이다. 우선 개발자는 바라는 향상 또는 새로운 함수를 정의하는 (초기적 결함을 점검하는 자동화된 테스트 케이스를 작성한다. 그런후에, 그 케이스를 통과하기위한 최소한의 양의 코드를 생성한다. 그리고 마지막으로 그 새코드를 표준에 맞도록 리팩토링한다. 이 기법을 개발했거나 ‘재발견’ 한 것으로 인정되는 Kent Beck은 2003년에 TDD가 단순한 설계를 장려하고 자신감을 불어넣어 준다고 말하였다. (위키백과 TDD) TDD에 대해 좀더 쉽게 접근해본다면 “테스트 주도 개발(Text-Driven Development)”이라는 용어 그대로 개발을 하는데 있어 테스트가 주가 되어 개발한다는 의미가 되겠다. → 즉, “테스트를 염두에둔 프로그램 개발방법” 정도가 되겠다. 아래의 그림을 통해 쉽게 이해해보자 이와같이 기존 개발 프로세스와 차이점을 알수있다. 테스트 코드를 작성하며 결과를 예상해볼수있기에 설계의 문제로 인한 오류 개선속도가 한층 빨라질것을 직관적으로 알수있다. 그렇다고 무작정 TDD를 사용하기에는 명확한 이유가 될수는 없기에 TDD의 장점에 대해알아보자 TDD의 장점 객체지향적 코드개발 테스트 코드를 먼저 작성한다면 좀 더 명확한 기능과 구조를 설계할수 있다. 각각의 함수 정의시 각각의 기능들에 대해 철저히 구조화 시켜 코드를 작성할수 있다. 테스트의 용이성을 위해 복잡한 기능을 한 함수에 모두 구현하지 않고 모든코드의 재사용성을 보장하며 코드를 작성함으로 기본적으로 객체지향적 코드가 된다. 설계수정 시간의 단축 테스트 코드를 먼저작성하기에 최초 설계안을 만족시키며 입출력 구조와 기능의 정의를 명확히 하여 설계의 구조적 문제를 쉽게 찾을수 있다. 테스트 시나리오를 작성해봄으로 코드 개발전 기능을 구현하기위한 예외 상황을 미리 확인하고 조사하게되어 예외 코드를 작성하기 쉬워진다. 디버깅 시간의 단축 단위 테스트 기반의 테스트 코드를 작성하므로 추후 문제발생시 모듈별로 테스트를 진행해 문제지점을 쉽게 찾을수있다. 예를 들어 문제가 발생할 수 있는 지점은 DB영역, Application 영역, Data영역, Memory 영역등 모든 영역을 통합 테스트시 문제 지점을 쉽게 찾을수 없지만, 각각의 단위 테스트 진행시 영역을 분할하여 쉽게 찾아낼수 있게된다. 유지보수의 용이성 대부분의 개발자는 설계 및 코드 작성시 기술적인 관점을 바라보며 기능자체의 구현에 초점이 맞춰짐으로 코드가 복잡해지고 테스트가 어려워지지만, TDD 개발로 인해 항상 그 테스트 요소들이 사용자 관점으로 정의되고 진행되기에 입력과 출력의 흐름이 명확해지고 추후 구조의 변경 및 소스 수정시 구조를 쉽게 파악하고 빠른 수정이 가능해진다. 더불어 재사용테스트도 쉽게 가능해진다. 테스트 문서의 대체가능 대부분의 개발 프로젝트 진행시 테스트를 진행하게되면 단순 통합 테스트에 지나지 않는다. 즉, 내부적 모듈이 어떻게 테스트 되었는지 제공할수 없다. 하지만 TDD를 구현하게되면 테스팅을 자동화 시킴과 동시에 보다 정확한 테스트 근거를 산출할수있게된다. TDD를 사용하며 개별 테스트를 일일히 진행하며 완성시키다보니 개발 시간이 늦어지는 단점이 보일수 있겠지만, 전체적인 개발시간은 비슷하거나 단축되는 효과가 있게된다. 이후 코드 수정 및 구조추가의 용의성을 생각했을때 TDD를 적용한 개발방법이 많은 도움이 될수있다. 참조 이미지참조 참조 추가적으로 읽어보면 좋은글","link":"/2021/04/13/TDD/"},{"title":"ThirdParty","text":"서드파티?하드웨어 생산자와 소프트웨어 개발자의 관계를 나타내는 용어로 사용된다. 하드웨어 생산자는 퍼스트파티(first party) 소프트웨어 개발자는 서드파티(third party) 123하드웨어 생산자가 **직접** 소프트웨어를 개발한다면? → **퍼스트 파티**하드웨어 생산자인 모기업과 자사관계로 소프트웨어 개발을한다 → **세컨드 파티**하드웨어 생산자인 모기업과 자사관계, 하청관계 전혀 관련없는 소프트웨어 개발 → **써드 파티** 프로그래밍 관점프로그래밍에서의 서드 파티라는 것은 편한 개발을위해 플러그인 이나 library 혹은 프레임워크를 사용하는데 이처럼 제 3자로써 중간다리 역할을 하는 것을 서드파티라고 한다. 또한 이런것들을 만드는 개발자가 서드 파티 개발자다. 즉, 제 3자가 만든 라이브러리로써 개인 개발자나 프로젝트 팀, 혹은 업체등에서 개발하는 라이브러리를 뜻하기도한다. 또한 프로그래밍 개발과 개발자 사이에 플러그인, 라이브러리 프레임 워크를 서드 파티로 볼수있다. 참조 위키백과 gyoogle 이미지참조","link":"/2021/04/07/ThirdParty/"},{"title":"Ubuntu&amp;Linux","text":"리눅스? 출처 위키백과 lewing@isc.tamu.edu Larry Ewing and The GIMP 우분투의 뿌리라고 할수 있는 리눅스는 많은 이들이 이미 접하고있다. 스마트폰의 안드로이드 운영체제 제일 밑단에서는 리눅스 커널을 기반으로 한다. 리눅스는 Unix를 기반으로 개발된 오퍼레이팅 시스템(OS)이다. 1990년대 초 *GUN(Gun is Not Unix) 프로젝트는 운영체제에 필요한 많은 프로그램을 만들어낸다. 그러나 장치 커널등이 완성되지 않았었는데, 1991년 리누스 토발즈가 사용자와의 인터페이스를 담당하는 리눅스커널을 발표한다. 그에때라 GUN/Linux 라는 완전한 운영체제가 탄생한다. GUN*(유닉스와 비슷한 운영체계로서, 복사, 수정 및 재배포가 가능하도록 소스코드가 함께 수록된 것을 말한다. 이것을 이용, 리눅스를 만들었다.) 리눅스의 특징 유닉스 기반기존의 유닉스는 높은 하드웨어 스펙을 기반으로 복잡하고 큰 네트워크 시스템을 위해 만들어진 운영체제였지만 리눅스는 여기에서 커널과 명령어 체계를 바꾸어 일반인들이 보다 사용하기 쉽게하였다. 다중 사용자와 멀티 태스킹을 지원리눅스는 다중 사용자와 멀티 태스킹을 지원한다. 떄문에 보안성이 높은 파일을 관리하기 용이하여 서버에서 많이 쓰이고 있다. 자유 소프트웨어리눅스는 자유 소프트웨어 라이센스를 가진다. 이는 누구나 소스코드를 사용, 수정 재배포가 가능하다는것이며, 이것이 다른 운영체제와의 가장큰 차이점이다. 가각의 리눅스 배포판은 서로다른 목적으로 저마다의 환경에서 사용되지만 리눅스 커널이라는 하나의 심장을 공유한다**.** 우분투란? 출처 위키백과 Canonical Ltd. - http://design.ubuntu.com/wp-content/uploads/logo-ubuntu_no®-black_orange-hex.svg ubuntu : 리눅스 커널만으로는 사용자가 시스템을 사용할수 없기에 필요에 따라 오픈소스로 개발된 각종 도구들을 추가해 배포하는 과정에서 생겨난 인기있는 리눅스 배포판이라 할수있다. 우분투의 특징 개인용, 데스트탑 환경에 최적화대부분의 리눅스 배포판들이 서버용으로 사용되고 있는것에 반하여, 우분투는 개인 사용자와 데스트탑 환경에 최적화 되도록 사용자 편의를 중점으로개발 자유 소프트 웨어에 기반누구나 무료로 다운 받아서 사용할수 있다. 우분투가 사용되고 있는곳시스템 화면과 로그인을 관리하는 Display Manager, 윈도우 창들을 관리하는 Window Manger, GUI와 관련된 Desktop Environment로 이루어져있다. 참조 우분투(ubuntu)란 무엇인가? 우분투란? ubuntu란? 리눅스란? 우분투 (운영 체제)","link":"/2021/04/13/Ubuntu-Linux/"},{"title":"VanilaJS-Array","text":"자료구조상의 배열은 동일한 크기의 메모리공간이 빈틈없이 연속되는 자료구조를 뜻하며, 하나의 데이터타입을 가지고 있는것을 뜻하며 이는 밀접배열이라한다. 이러한 배열은 정렬되어있는 상태라면 접근하여 값을 찾는경우 매우빠르게 동작하겠지만, 그렇지 않은 경우에는 정렬시간과 값을 찾는시간이 더해져 효율적이지 못하게된다. 자바스크립트의 배열은 메모리공간이 동일한 크기를 가지지 않아도 되며, 연속되지 않을수있다. 자바스크립트에서 배열의 구조가 연속적으로 이어져 있지 않은 배열은 희소배열이라한다. 자바스크립트의 배열은 사실 객체이다. 자료구조상의 배열을 흉내낸 해시테이블 구조를 가진 객체이며, 배열 안의 요소는 element라고 불리운다. 배열은 자신의 위치를 나타내는 0 이상의 정수인 index를 가진다. 배열은 요소의 개수를 나타내는 length 프로퍼티를 가진다. 배열의 인덱스는 사실 프로퍼티키이며, 문자열이다. “일반 객체와 배열을 구분하는 가장 명확한 차이는 index(값의 순서)와 length 프로퍼티가 있다는 점이다.” length 프로퍼티 그리고 희소배열length 프로퍼티는 요소의 개수 즉, 배열의 길이를 나타낸다. 빈 배열일경우에는 0이며 아닐경우 가장 큰 인덱스에 1을 더한것과 같다. 12console.log([].length); // 0console.log([1, 2, 3, 4].length); // 4 희소배열은 length프로퍼티가 배열이 가진 요소의 개수보다 크고, 일부가 비어 있는 배열을 희소 배열이라고 할수있다. 123const arr = [1, 2, 3];arr.length = 100;console.log(arr); // (100) [1, 2, 3, empty × 97] 배열의 생성방식 배열리터럴 가장 기본적인 배열 생성 방식이다. 1const arr = []; // 배열리터럴 Array 생성자함수 전달된 인수가 2개 이상이거나 숫자가 아닌경우 인수를 요소로 갖는 배열이 생성된다. 이때 숫자를 넣게되면 희소배열이 만들어진다. new 연산자와 함께 호출하지 않아도 Array 생성자 함수내의 new.target에 의해 생성자함수로 동작한다. 12345const arr1 = new Array('얍');console.log(arr1); // ['얍']const arr2 = new Array(10);console.log(arr2); // (10) [empty × 10] Array.of( ) 전달된 인수가 숫자이고 1개여도 배열이 만들어진다. 12const arr = Array.of(1);console.log(arr); // [1] Array.from( ) 유사배열객체와 이터러블을 인수로 전달받아 배열로 변환해 반환한다. 123const foo = 'hello';const result = Array.from(foo);console.log(result); // (5) [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] 배열의 요소참조배열의 요소참조는 [] 대괄호 표기법을 이용해 이루어지며, 대괄호 안에는 인덱스가 와야하며, 정수로 평가되는 표현식도 인덱스 대신 사용이 가능하다. 배열의 인덱스는 프로퍼티 키이며 존재하지 않는 프로퍼티로 객체의 프로퍼티에 접근했을경우 undefied를 반환하는것처럼 배열에서도 동일하게 작동된다. 12const arr = [1, 2, 3];console.log(arr[3]); //undefined 배열 메서드배열메서드는 원본배열을 변경하는 메서드, 원본배열을 변경하지 않는 메서드 두가지로 나뉜다. 사용빈도가 비교적 높고 대표적인 배열메서드를 알아보자. Array.isArray( ) 인수로 전달된 값이 배열인지 아닌지를 확인하는 메서드이다. 반환되는 데이터타입은 boolean이다. 12345const arr1 = [1, 2, 3];const arr2 = {};console.log(Array.isArray(arr1)); // trueconsole.log(Array.isArray(arr2)); // false Array.prototype.indexOf( ) 인수로 전달된 요소를 검색해 인덱스를 반환한다. 만약 중복되는 요소가 있다면 첫번째로 검색된요소의 인덱스를 반환한다. 원본배열에 인수로 전달된 요소가 존재하지 않으면 -1을 반환한다. 두번째 인수는 검색을 시작할 인덱스이며 생략시 처음부터 검색한다. 12const arr = [1, 2, 3];console.log(arr.indexOf(2)); // 1 Array.protorype.push( ) 인수로 전달받은 값을 원본배열의 마지막요소로 추가한다. 반환되는 값은 원본배열의 length 프로퍼티이다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.push(4);console.log(arr); // [1, 2, 3, 4]console.log(result); // 4 원본배열을 훼손하는 행위는 권장하지 않는다. 그렇기에 ES6에서 추가된 스프레드 문법을 활용하는것이 바람직하다. ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [...arr, 4];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] Array.prototype.pop( ) 원본 배열의 마지막요소를 제거한다 제거된 요소를 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.pop();console.log(arr); // (2) [1, 2]console.log(result); // 3 Array.prototype.unshift( ) 원본배열의 선두요소에 인수로 전달받은 값을 추가한다. 반환되는 값은 원본배열의 length 프로퍼티이다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.unshift(4);console.log(arr); // (4) [4, 1, 2, 3]console.log(result); // 4 원본배열을 훼손하는 행위는 권장하지 않는다. 그렇기에 ES6에서 추가된 스프레드 문법을 활용하는것이 바람직하다. ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [4, ...arr];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [4, 1, 2, 3] Array.prototype.shift( ) 원본배열에서 첫번째 요소를 제거한다. 제거된 요소를 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.shift();console.log(arr); // (2) [2, 3]console.log(result); // 1 Array.prototype.concat( ) 원본배열의 마지막에 인수로 전달받은 값을 추가한다. ( 전달된 값이 배열이면 해체하여 새로운 배열의 요소로 추가한다. ) 변경된 새로운 배열을 반환한다. 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.concat(4);console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] ES6의 스프레드 문법으로 대체해서 사용하기 12345const arr = [1, 2, 3];const result = [...arr, 4];console.log(arr); // (3) [1, 2, 3]console.log(result); // (4) [1, 2, 3, 4] Array.prototype.splice( StartIndex, deleteCount, [item]) 원본배열의 중간에 요소를 추가 혹은 제거한다. StartIndex - 원본배열의 요소를 제거하기 시작할 인덱스 ( StartIndex만 지정하면 모든 요소제거 ) deleteCount - 원본배열의 요소를 제거할 개수 ( 0 이면 어느것도 제거되지 않는다. ) item - 원본배열의 요소를 제거한 위치에 삽일할 요소들의 목록 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.splice(1, 2, 3, 4);console.log(arr); // (3) [1, 3, 4]console.log(result); // (2) [2, 3] Array.prototype.slice( StartIndex, EndIndex ) 인수로 전달된 범위의 요소를 복사한다. 원본배열을 복사한 배열을 반환한다. ( 인수를 모두 생략하면 원본배열의 복사본을 생성해 반환한다. ) StartIndex - 원본배열의 복사를 시작할 인덱스 ( 음수일경우는 맨 마지막 요소에서 -n 이후의 값을 반환 ) EndIndex - 원본배열의 복사를 종료할 인덱스 ( 해당요소는 미포함 , 기본값은 length 프로퍼티 값 ) 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.slice(1, 2);console.log(arr); // (3) [1, 2, 3]console.log(result); // [2] Array.prototype.join( ) 원본배열의 모든요소를 문자열로 변환한다. 인수로 전달받은 값( 구분자 )으로 연결한 문자열을 반환한다. 기본 구분자는 콤마이다. , 원본배열을 변환시키지 않는다. 12345const arr = [1, 2, 3];const result = arr.join('');console.log(arr); // (3) [1, 2, 3]console.log(result); // 123 Array.prototype.reverse( ) 원본배열의 순서를 반대로 뒤집는다. 변경된 원본배열을 반환한다. 원본배열을 변환시킨다. 12345const arr = [1, 2, 3];const result = arr.reverse();console.log(arr); // (3) [3, 2, 1]console.log(result); // (3) [3, 2, 1] Array.prototype.fill( _ , StartIndex, StopIndex ) ES6 인수로 전달 받은 값을 배열의 요소로 처음부터 끝까지 채운다. _ - 배열을 채울 요소 StartIndex - 요소를 채우기 시작할 인덱스 StopIndex - 요소를 채우는것을 멈출인덱스 ( 해당 요소는 미포함 ) 원본배열을 변환시킨다. 12345const arr = new Array(10);const result = arr.fill(1, 2, 10);console.log(arr); // (10) [empty × 2, 1, 1, 1, 1, 1, 1, 1, 1]console.log(result); // (10) [empty × 2, 1, 1, 1, 1, 1, 1, 1, 1] Array.prototype.includes( SearchElement, StartIndex ) ES7 원본 배열에 특정요소가 포함되어있는지 확인한다. true 혹은 false를 반환한다. SearchElement - 검색할 대상지정 StartIndex - 검색을 시작할 인덱스 12345const arr = [1, 2, 3];const result = arr.includes(2, 1);console.log(arr); // (3) [1, 2, 3]console.log(result); // true Array.prototype.flat( ) ES10 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다. 기본값은 1단계 평탄화이다. Infinity를 인수로 전달하면 중첩배열을 모두 평탄화한다. 1234console.log([1, [2, 3, 4, 5]].flat()); // (5) [1, 2, 3, 4, 5]console.log([1, [2, [3, 4, 5]]].flat(1)); // (5) [1, 2, 3, 4, 5]console.log([1, [2, [3, [4, 5]]]].flat(2)); // (4) [1, 2, 3, Array(2)]console.log([1, [2, [3, [4, [5]]]]].flat(Infinity)); // (5) [1, 2, 3, 4, 5]","link":"/2021/04/02/VanilaJS-Array/"},{"title":"VanilaJS-HOF","text":"배열고차함수 (Array Higher Order Function in JS) 고차함수(Higher-Order-Function)는 함수를 인수로 전달받거나 반환하는 함수를말한다. 자바스크립트에서 활용도가 매우높은 배열에사용되는 고차함수에 대해 알아보자. Array.prototype.sort( ) 원본배열의 요소를 정렬한다. ( 기본적으로 오름차순으로 요소를 정렬한다. ) 정렬된 배열을 반환한다. 원본배열이 변환된다. 12345const arr = [1, 3, 5, 20, 11];const result = arr.sort();console.log(arr);) // [1, 11, 20, 3, 5]console.log(result); // [1, 11, 20, 3, 5] 필자는 “sort 메서드를 따로 분류해서 페이지를 만들까?” 까지 고민할정도로 중요하고 또 어렵게 느껴졌다. 좀더 자세히 sort 메서드에 대해 알아보자. sort 메서드는 배열안의 요소에 따라 다르게 동작한다. 문자열로 이루어진 배열의 경우 숫자로 이루어진 배열의 경우 sort 메서드는 숫자로 이루어진 배열의 요소들을 일시적으로 문자열로 변환시켜 유니코드의 순서를 기준으로 정렬한다. 먼저 유니코드(Unicode)에 관해서 간단하게 설명한다면, 컴퓨터에서 사용되는 모든기호나 문자들에 관해서 컴퓨터가 이해할수있게 만들어 놓은 표기방식이라고 할수있겠다. sort메서드는 유니코드를 기준으로 배열안의 요소들을 정렬하게 되는데 기존에 문자열 같은경우는 우리가 알고있는 알파벳순서에 따라 정상적으로 잘 동작한다. 12345const fruits = ['Apple', 'Orange', 'Banana', 'Peach', 'Grape'];const result = fruits.sort();console.log(fruits); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Grape&quot;, &quot;Orange&quot;, &quot;Peach&quot;]console.log(result); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Grape&quot;, &quot;Orange&quot;, &quot;Peach&quot;] 하지만, 숫자 같은 경우 조금 다르다. 12345const arr = [1, 3, 5, 20, 11];const result = arr.sort();console.log(arr);) // [1, 11, 20, 3, 5]console.log(result); // [1, 11, 20, 3, 5] 위 예시처럼 숫자같은경우는 11과 20이 3과 5보다 먼저 정렬된다. 이는 유니코드 표기법에 의해 정렬되었기 때문이다. 즉, 숫자에서 일시적으로 문자로 변환된 문자열들을 유니코드를 기준으로 비교하면 문자열 ‘11’이 ‘20’, ‘3’, ‘5’ 보다 더 앞서기 때문이다. 비교함수 전달하기따라서 숫자요소를 정렬할때는 특별히 비교함수를 sort 메서드 안으로 전달해야한다. 0을 기준으로 오름차순과 내림 차순이 결정된다. 반환되는 값이 0 이상이면 오름차순 ( 0 &lt; returnValue ) - 첫번째 인수를 우선으로 하여 정렬 반환되는 값이 0 이면 정렬하지 않음 반환되는 값이 0 이하면 내림차순 ( 0 &gt; returnValue ) - 두번째 인수를 우선으로 하여 정렬 오름차순정렬 12345678const arr = [3, 10, 21, 14, 5];const compare = (next, prev) =&gt; { return next - prev;};const result = arr.sort(compare);console.log(arr); // (5) [3, 5, 10, 14, 21]console.log(result); // (5) [3, 5, 10, 14, 21] 내림차순정렬 12345678const arr = [3, 10, 21, 14, 5];const compare = (next, prev) =&gt; { return prev - next;};const result = arr.sort(compare);console.log(arr); // (5) [21, 14, 10, 5, 3]console.log(result); // (5) [21, 14, 10, 5, 3] 위 코드의 compare 매개 변수의 이름을 잘보면 next, prev 라고 명시했다. 이는 sort 메서드 내부동작의해서 원본배열의 secondIndex가 next로 들어가고 firstIndex가 prev로 들어가기에 이렇게 작성했다. 필자는 이것을 알아내느라 하루를 소모했다..😂 sort 메서드 관련 좀더 자세한 사항은 아래의 이곳, 저곳, 요곳을 참조하면된다! 유니코드 관련 참조사이트 https://ko.wikipedia.org/wiki/유니코드 https://d2.naver.com/helloworld/19187 https://graphemica.com/ https://unicode-table.com/kr/#basic-latin Array.prototype.forEach((currentValue, index, arr), [thisArg]) for문을 대체할수 있는 고차함수이다. 자신을 호출한 배열의 모든요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. forEach 문의 반환값은 언제나 undefined이다. 원본배열을 변경하지않는다. 12345const numbers = [1, 2, 3, 4, 5];const result = numbers.forEach((number) =&gt; number * 2);console.log(numbers); // (5) [1, 2, 3, 4, 5]console.log(result); // undefined forEach문은 원본 배열을 변경하지 않지만, 콜백함수를 통해 원본 배열을 변경할수는 있다. 12345678910const numbers = [1, 2, 3, 4, 5];const result = numbers.forEach((number, index, arr) =&gt; { console.log(number); // 1 2 3 4 5 console.log(index); // 0 1 2 3 4 console.log(arr); // [2, 2, 3, 4, 5] ··· 순회시마다 원본배열은 변화 return (arr[index] = number * 2);});console.log(numbers); // (5) [2, 4, 6, 8, 10]console.log(result); // undefined 콜백함수의 3번째 인수로 전달된 원본배열을 index로 직접 참조해서 값을 변경하는것이 가능하다. 콜백함수안으로 this의 전달과 그 이유forEach 메서드의 두번째 인수로 this로 사용할 객체를 전달할수있다. 1234567891011121314class Numbers { numberArray = []; multiply(arr) { arr.forEach(function (elem) { this.numberArray.push(elem * elem); }, this); console.log(this); // Numbers {numberArray: Array(3)} }}const arr = new Numbers();arr.multiply([1, 2, 3]);console.log(arr.numberArray); // (3) [1, 4, 9] 이는 일반함수로 호출한 this의 값은 전역객체(window)를 가르키기에 콜백함수내에서 사용될 this의 값과 고차함수의 몸체안에서의 this와 일치시키기 위함이다. class함수 내에서 this를 전달하지 않는다면 typeError: Cannot read property ‘numberArray’ of undefined가 발생하는데 이는 클래스 내부의 모든 코드에는 암묵적으로 strictmode가 적용되기 떄문이다. 다시말해, class함수 내에서 strictmode(엄격모드)가 적용될때 this가 전역객체(window)를 가리키는것은 this의 사용이유(자신이 속한 위치를 나타내는것)가 적절하지 못하기때문에 undefined를 반환하게된다. 보통 ES6 이후부터는 화살표함수(자체적인 this를 가지지 않는다.)를 사용함으로써 상위 스코프의 this를 가르키게끔 하여 이러한 문제를 해결한다. 그리고 forEach문은 break, continue문을 사용할수 없으며, 배열의 모든 요소를 순회한다. Array.prototype.map((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값들로 구성된 새로운 배열을 반환한다. 콜백함수의 반환값이 map메서드를 호출한 배열의 요소를 1 : 1 매핑한다. 원본배열이 변환되지 않는다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.map((v, i, arr) =&gt; v * 2);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // (5) [2, 4, 6, 8, 10] Array.prototype.map 메서드는 메서드를 호출한 배열의 각각의 요소값을 다른 값으로 매핑하여 새로운 배열을 생성하기 위해 사용한다. Array.prototype.filter((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다. 원본배열이 변환되지 않는다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.filter((v, i, arr) =&gt; v &lt; 2);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // [1] Array.prototype.filter 메서드는 메서드를 호출한 각각의 요소값들중 콜백함수로 전달한 조건에 만족하는(반환값이 true) 요소로 이루어진 배열을 반환한다. Array.prototype.reduce((accumulator, currentValue, index, arr), [InitialValue]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값을 다음순회시에 콜백함수의 첫째인수로 전달한다. 하나의 결과값을 반환한다. 원본배열이 변환되지 않는다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.reduce((acc, cur, index, arr) =&gt; acc + cur, 0);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // 15 Array.prototype.reduce 메서드는 메서드를 호출한 각각의 요소값들중 콜백함수로 전달된 초기값(initialValue)과 계산식을 가지고 배열의 요소를 계산하여 반환되는 값을 콜백함수의 첫번째 인수(acc)로 넘겨주면서 호출한다. 즉, 값을 계속 누산하여 하나의 결과값을 반환한다. reduce메서드의 초기값 전달과 그 이유1234567891011121314const arr = [1, 2, 3, 4, 5];const result = arr.reduce((acc, cur, index, arr) =&gt; acc + cur, 0);/* acc + cur 0 + 1 1 + 2 3 + 3 6 + 4 10 + 5*/console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // 15 이때, reduce 메서드의 두번째 인수로 전달하는 초기값은 첫번째 순회에 콜백함수의 첫번째 인수로 전달된다. 그래서 위 예제의 첫번째 순환값은 1이다. reduce메서드의 두번째 인수로 전달되는 초기값은 옵션이지만 생략하지 않는것이 좋다. 이는 reduce메서드를 호출하는 배열이 빈배열일 경우에 에러발생이 일어나는것을 방지할수있다. 123456const arr = [];const result = arr.reduce((acc, cur, index, arr) =&gt; acc + cur);/* Uncaught TypeError: Reduce of empty array with no initial value */console.log(arr);console.log(result); 또한 객체의 특정 프로퍼티값을 합산하는 경우에는 반드시 초기값을 전달해야한다. 12345678910111213141516const goods = [ { id: 1, price: 300 }, { id: 2, price: 500 }, { id: 3, price: 700 },];/* acc + cur 300 + 500 800.price? + 700 NaN*/const result = goods.reduce((acc, cur, index, arr) =&gt; acc.price + cur.price);console.log(goods); // (3) [{…}, {…}, {…}]console.log(result); // NaN 위의 식은 acc.price + cur.price 인데 아래의식은 acc + cur.price 인 이유는 위의 식은 값을 숫자값들을 더하기위해 어쩔수 없이 작성하였지만, 아래의 식은 초기값을 전달하면서 첫번째 순회시 acc의 값이 0으로 전달되기에 acc + cur.price 만으로 얻고싶은 값을 얻어낼수있다. 1234567891011121314151617const goods = [ { id: 1, price: 300 }, { id: 2, price: 500 }, { id: 3, price: 700 },];/* acc + cur 0 + 300 300 + 500 800 + 700 1500*/const result = goods.reduce((acc, cur, index, arr) =&gt; acc + cur.price, 0);console.log(goods); // (3) [{…}, {…}, {…}]console.log(result); // 1500 reduce에 대한 더 많은 활용법과 예제는 이곳을 참고하자😁 Array.prototype.some((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 단 한번이라도 참이면 true, 모두 거짓이면 false를 반환한다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.some((v, i, arr) =&gt; v &gt; 4);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // true Array.prototype.some메서드는 메서드를 호출한 배열의 요소중 콜백함수에서 정의한 조건을 만족하는 요소가 단 한개라도 존재한다면 true를 반환한다. 단, 메서드를 호출한 배열이 빈배열일 경우는 false를 반환한다. Array.prototype.every((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 모두 참이면 true, 단 하나라도 거짓이면 false를 반환한다. 12345const arr = [1, 2, 3, 4, 5];const result = arr.every((v, i, arr) =&gt; v &gt; 4);console.log(arr); // (5) [1, 2, 3, 4, 5]console.log(result); // false Array.prototype.every메서드는 메서드를 호출한 배열의 모든 요소들이 콜백함수에서 정의한 조건을 만족한다면 true를 반환한다. Array.prototype.find((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 true인 첫번째 요소를 반환한다. true인 요소가 존재하지 않는경우 undefined를 반환한다. 1234567891011const ranking = [ { id: 1, color: 'green' }, { id: 2, color: 'red' }, { id: 3, color: 'blue' }, { id: 4, color: 'yellow' }, { id: 5, color: 'blue' },];const result = ranking.find((v, i, arr) =&gt; v.color === 'blue');console.log(result); // {id: 3, color: &quot;blue&quot;} Array.prototype.find메서드는 메서드를 호출한 배열의 요소들중 콜백함수로 정의한 조건에 만족하는 첫번째 요소를 반환한다. Array.prototype.findIndex((currentValue, index, arr), [thisArg]) 자신을 호출한 배열의 모든 요소를 순회한다. 콜백함수로 수행해야할 처리를 전달받아 반복호출한다. 콜백함수의 반환값이 true인 첫번째 요소의 인덱스를 반환한다. 반환값이 true인 요소가 없다면 -1을 반환한다. 1234567891011const ranking = [ { id: 1, color: 'green' }, { id: 2, color: 'red' }, { id: 3, color: 'blue' }, { id: 4, color: 'yellow' }, { id: 5, color: 'blue' },];const result = ranking.findIndex((v, i, arr) =&gt; v.color === 'blue');console.log(result); // 2 Array.prototype.findIndex메서드는 메서드를 호출한 배열의 요소들중 콜백함수로 정의한 조건에 만족하는 첫번째 요소의 인덱스를 반환한다. 추가적인 배열 메서드와 관련해서는 이곳을 참고하길 바란다.","link":"/2021/04/02/VanilaJS-HOF/"},{"title":"VanilaJS-First-class citizens","text":"일급객체(first-class citizens)?프로그래밍 언어에서 일급객체란, 다른 객체들에게 적용가능한 연산을 모두 지원하는 객체를 말한다. (매개변수로 전달, 함수에서 반환되고 수정되고 변수에 할당되는 것들) 프로그래밍언어에 따라 다른 일급 객체의 조건들 중 자바스크립트의 경우에는 아래의 4가지 조건을 만족하면 일급 객체라 칭하는데 함수는 아래의 경우를 모두 만족하므로 일급 객체다. 무명의 리터럴로 생성할수 있다. 소스코드의 실행과정에서 생성이 가능해야한다. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다. 함수의 매개변수(파라미터)에 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 12345678910111213141516171819202122232425262728// 1. 소스코드의 실행과정에서 생성가능하다.const foo = function (a) { return a;};foo(1);// 2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.const bar = { foo };// 3. 함수의 매개변수(파라미터)에 전달할 수 있다.const baz = function (f) { return f;};baz(bar);// 4. 함수의 반환값으로 사용할 수 있다.const func = function () { let num = 0; return function (b) { return num + b; };};const result = func();console.log(result(2)); 함수가 일급 객체 라는 것은 함수와 객체를 동일하게 사용할수 있다는 의미이다. 객체는 값이므로 함수도 값으로 평가가 가능하다는것이다.즉, 함수는 값이 위치할수있는 곳은 변수 할당문, 객체의 프로퍼티값, 배열의 요소, 함수호출문의 인수, 함수 반환문등 어디서든지 리터럴로 정의가 가능하며 소스코드 실행시에 함수 객체로 평가된다. 함수객체와 일반객체의 차이점함수는 객체다. 따라서 함수도 프로퍼티를 가질수 있다. 12345function sum(num1, num2) { return num1 + num2;}console.dir(sum); // 아래 이미지 참조 sum 함수의 모든 프로퍼티 어트리뷰트를 참조하려면 Object.getOwnPropertyDescriptors 메서드로 확인할수있다. 12345678910111213function sum(num1, num2) { return num1 + num2;}console.log(Object.getOwnPropertyDescriptors(sum));/* arguments: {value: null, writable: false, enumerable: false, configurable: false} caller: {value: null, writable: false, enumerable: false, configurable: false} length: {value: 2, writable: false, enumerable: false, configurable: true} name: {value: &quot;sum&quot;, writable: false, enumerable: false, configurable: true} prototype: {value: {…}, writable: true, enumerable: false, configurable: false} __proto__: Object*/ 함수 객체 고유 프로퍼티 arguments caller length name prototype 위 예제에서 볼수있듯이 함수객체에는 고유의 프로퍼티가 존재한다. __proto__ 프로퍼티는 접근자 프로퍼티로 함수고유의 프로퍼티는 아니다. Object.prototype 객체의 프로퍼티로써 모든 객체가 상속받아 사용이 가능하다. arguments 프로퍼티함수 객체의 arguments(인수) 프로퍼티 값은 arguments객체이다. 이는 함수 호출시 전달된 인수를 가지고 있는 순회가능한 유사배열객체이다. 이는 함수내에서 지역변수처럼 사용되며 함수 외부에서는 참조할수없다. 1234567891011121314151617181920212223242526272829function sum(num1, num2) { console.log(arguments); return num1 + num2;}console.log(sum(1, 2));/* Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ] 0: 1 1: 2 callee: ƒ sum(num1, num2) length: 2 Symbol(Symbol.iterator): ƒ values() __proto__: Object */// 3console.log(sum(3, 4, 5));/* Arguments(3) [3, 4, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] 0: 3 1: 4 2: 5 callee: ƒ sum(num1, num2) length: 3 Symbol(Symbol.iterator): ƒ values() __proto__: Object*/// 7 arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서(인덱스)를 나타낸다. 또한 인수의 개수를 초과한 인수는 무시되며 arguments 객체의 프로퍼티에 보관된다. 여기서 인수의 갯수를 적게 전달할 경우에는 함수 호출이후 함수 몸체내에서 매개변수는 함수 코드 평가과정에서 먼저 실행되며 이후 undefined로 초기화 되기때문에 값을 할당하지 않으면 NaN을 반환한다. 자바스크립트의 특성상 함수 호출시 인수의 갯수를 확인하지 않기에 이는 인수 갯수에 따라 함수 동작을 달리 정의해야할 경우에 유용하게 사용되는것이 arguments 객체이다. 즉, arguments객체는 매개변수개수를 확정할수 없는 가변인자 함수를 구현할때 유용하다. 12345678910111213function sum() { let result = 0; for (let i = 0; i &lt; arguments.length; i++) { result += arguments[i]; } return result;}console.log(sum(1, 2));console.log(sum(1, 2, 3));console.log(sum(1, 2, 3, 4)); 즉, 함수 내에서 arguments 객체는 고유프로퍼티로써 인수로 전달된값을 프로퍼티값으로 가지고 있고, 프로퍼티 값에 따른 프로퍼티키는 인수로 전달된순서 (인덱스)로 저장한다. 또한 length 프로퍼티를 가지고 있으며, 순회 가능한 유사배열객체 이다. callee 프로퍼티현재 실행중인 함수를 가르킨다. caller 프로퍼티함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다. 이는 ECMAScript 사양에 포함되지 않은 비표준이다. length 프로퍼티함수 객체의 length 프로퍼티 값은 함수를 정의할떄 선언한 매개변수의 개수를 의미한다. arguments 객체의 length는 함수 호출문의 인수의 개수를 가리키고 함수 객체의 length 프로퍼티값은 매개변수의 개수를 나타내므로 헷갈리지 않도록해야한다. name 프로퍼티함수 객체의 name 프로퍼티는 함수 이름을 나타내며 이는 함수객체의 식별자를 값으로 가진다. ES5에서는 함수 이름을 name 프로퍼티의 값으로 가지고 있었지만, ES6부터는 함수를 가르키는 변수 식별자를 값으로 가진다. __proto__접근자 프로퍼티모든 객체는 [[prototype]] 이라는 내부 슬롯을 가지는데 이는 상속을 구현하는 프로토타입 객체를 가리키며 이에 간접적으로 접근하기 위해 __proto__를 사용한다. prototype 프로퍼티prototype 프로퍼티는 생성자 함수로 호출할 수 있는 함수 객체, 즉 construcrot만이 가지는 프로퍼티이며 일반객체와 생성자 함수로 호출할수 없는 ES6의 화살표 함수와 메서드 축약표현에는 prototype 키가 없다. 참조 읽어보면 좋은글 일급 객체 - 위키백과 MDN - arguments 객체 First-class object (일급 객체)","link":"/2021/04/14/VanilaJS-First-class-citizens/"}],"tags":[{"name":"Technical Terms","slug":"Technical-Terms","link":"/tags/Technical-Terms/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"CrossPlatform","slug":"CrossPlatform","link":"/tags/CrossPlatform/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"PasS","slug":"PasS","link":"/tags/PasS/"},{"name":"Cloud Service","slug":"Cloud-Service","link":"/tags/Cloud-Service/"},{"name":"RSS","slug":"RSS","link":"/tags/RSS/"},{"name":"TDD","slug":"TDD","link":"/tags/TDD/"},{"name":"ThirdParty","slug":"ThirdParty","link":"/tags/ThirdParty/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"forEach","slug":"forEach","link":"/tags/forEach/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"filter","slug":"filter","link":"/tags/filter/"},{"name":"reduce","slug":"reduce","link":"/tags/reduce/"},{"name":"some","slug":"some","link":"/tags/some/"},{"name":"every","slug":"every","link":"/tags/every/"},{"name":"find","slug":"find","link":"/tags/find/"},{"name":"findIndex","slug":"findIndex","link":"/tags/findIndex/"},{"name":"First-class Object","slug":"First-class-Object","link":"/tags/First-class-Object/"},{"name":"Function Property","slug":"Function-Property","link":"/tags/Function-Property/"}],"categories":[{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Technical Terms","slug":"CS/Technical-Terms","link":"/categories/CS/Technical-Terms/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"Array","slug":"JS/Array","link":"/categories/JS/Array/"},{"name":"Function","slug":"JS/Function","link":"/categories/JS/Function/"}]}